
## 笔记一

对于不固定的字节类型， 会默认放在堆上（成为堆上的一个资源)

```rust
fn main() {
    let s1 = String::from("I am a superman");

    let s2 = s1;

    println!("{s1}");

    println!("{s2}");
}
```


浅拷贝/内存安全：默认只进行值复制 ，rust中默认只保留最新的s2到字符串的指向。
同时抹除s1到字符串的指向。

Rust中，每一个值（资源）都有一个所有者。

任何一个时刻，一个值只有一个所有者。

当所有者所在任何域结束的时候，值会被释放掉。


## 笔记二


**移动还是复制** 

默认做复制操作的有：

所有的整数类型：比如u32 

布尔类型：bool

浮点类型：f32 、 f64

字符串类型：char

由以上类型组成的tuple


## 笔记三

所有权

Rust中，每一个值（资源）都有一个所有者；

任何一个时候，一个值只有一个所有者；

当所有者所在作用域结束的时候，值会被释放掉；


```rust 
let b = &a;

let c = b;
```


```rust
fn main() {
    let a = 10u32;

    let b = &a;

    let c = &&&&&a;

    let d = &b;

    let e = b;

    println!("{a}");

    println!("{b}");

    println!("{c}");

    println!("{d}");

    println!("{e}");
}


```


10
10
10
10
10


## 笔记四

引用的作用域是从它定义到它最后一次使用时结束


## 笔记五 

用&和&mut来改进函数的定义

如果一个函数参数接受的是可变引用，或所有权参数，那么它
里面的逻辑一般都会对引用的资源进行修改。如果一个函数
参数只接受不可变引用，那么它里面的逻辑，就一定不会修改
被引用的资源。





